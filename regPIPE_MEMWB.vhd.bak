
-- Quartus Prime VHDL Template
-- One-bit wide, N-bit long shift register with asynchronous reset

library ieee;
use ieee.std_logic_1164.all;

entity regPIPE_MEMWB is

	generic
	(
		NUM_BITS : natural := 3
	);

	port 
	(
		clk	    : in std_logic;
		enable	: in std_logic;
		reset   : in std_logic;
		
		PC_4_in : in std_logic_vector(NUM_BITS - 1 downto 0);
		PC_4_out : out std_logic_vector(NUM_BITS - 1 downto 0);
			
		write_back_in : in std_logic_vector(NUM_BITS - 1 downto 0);
		write_back_out : out std_logic_vector(NUM_BITS - 1 downto 0); 
	
		memory_access_in : in std_logic_vector(NUM_BITS - 1 downto 0);
		memory_access_out : out std_logic_vector(NUM_BITS - 1 downto 0);
	
		execute_in : in std_logic_vector(NUM_BITS - 1 downto 0);
		execute_out : out std_logic_vector(NUM_BITS - 1 downto 0);

		add_result_in : in std_logic_vector(NUM_BITS - 1 downto 0);
		add_result_out : out std_logic_vector(NUM_BITS - 1 downto 0);

		ALU_result_in : in std_logic_vector(NUM_BITS - 1 downto 0);
		ALU_result_out : out std_logic_vector(NUM_BITS - 1 downto 0);
		
		zero_in : in std_logic;
		zero_out : out std_logic
	);

end entity;

architecture MEMWB of regPIPE_MEMWB is
--	signal data_s : std_logic_vector(NUM_BITS - 1 downto 0) := (OTHERS=>'0');
begin
	process (clk, reset)
		begin
			if (rising_edge(clk)) then
				PC_4_out <= PC_4_in;
				
				execute_out <= execute_in;
				
				write_back_out <= write_back_in;
				
				memory_access_out <= memory_access_in;
				
				read_data1_out <= read_data1_in
				
				read_data2_out <= read_data2_in
				
--				Instruction_out <= Instruction_in;
				
--				data_s <= data_in;
				
			end if;
		end process;

		--data_out <= data_s;

end MEMWB;
